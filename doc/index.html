
<html>
  <style>
    body {
      background: #fff;
      color: #2e3436;
      font-size: 12pt;
      line-height: 16pt;
  /*  font-family: Palatino;  */
      margin: 3em 0 3em 3em; 
    }

    code, pre {
      background: #ffefff;
    }

    #contents {
      max-width: 40em;
    }

    ul {
      padding-left: 0;
    }

    li {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
    }

    p {
      text-align: justify;
    }


    img {
      float: left;
      margin: 0 1em 1em 0;
    }

    p { clear: both; }
  </style>
  <body> <div id="contents">
    <img src="icon.png"/>
    <h1>libebb</h1>

    <p>
      libebb is a lightweight HTTP server library for C.  It lays the
      foundation for larger web servers by providing the socket juggling and
      request parsing. By implementing nearly exactly the HTTP/1.1 grammar
      provided in RFC2612,  libebb understands most most valid HTTP/1.1
      connections (persistent, pipelined, and chunked requests included) and
      rejects invalid or malicious requests.  The library uses a strict
      single threaded evented design, buffering nothing; most of the API is
      registering callbacks.
    </p>

    <p>
      libebb intends to be the central engine for new high-performance web
      servers. Towards this goal it takes a mimimalistic philosophy and
      attemps to not interfere with the goals of the server designer.  For
      example, it passes all decisions of memory allocation to the user of
      the library.
    </p>

    <p>
      libebb does not support SSL, but may in the future.
    </p>

    <p>
      libebb is in the early stages of development and probably contains
      many bugs. The API is subject to radical changes.  If you're
      interested do <a
        href="http://github.com/ry/libebb/tree/master">checkout the
        source</a> and <a href="mailto:ry@tinyclouds.org">offer
        feedback</a>.  
      Releases will be made when it proves stable.
    </p>

    <h2>Usage</h2>

    <p>
      libebb is a simple API, mostly it provides callbacks to receive data
      as it comes through the socket.  There are two classes of callbacks
      that one will work with: 
    </p>
    <ul>
      <li>callbacks to allocate and initialize data for libebb</li>
      <li>callbacks which provide pointers to request data. (For
      example, a pointer to where the Request URI is located.)</li>
    </ul>
    <p>
      There are five classes: 
      <code>ebb_server</code>, 
      <code>ebb_connection</code>, 
      <code>ebb_request</code>,
      <code>ebb_buf</code>, 
      and 
      <code>ebb_request_parser</code>. 
    </p>

    <h3><code>ebb_server</code></h3>
    <p>
      <code>ebb_server</code> requires that you provide it with a libev
      event loop.  This event loop is yours to control as you like, in
      particular you must be the one to call <code>ev_loop</code>. Ebb needs
      the loop so it can attach its watchers. 
    </p>

    <p>
      The server class also requires that you provide it with a callback
      <code>new_connection</code>. This callback must return an allocated
      and initialized <code>ebb_connection</code> structure.  This callback
      will be made just as the server accepts a client connection but before
      any data is pulled from the socket.
    </p>

    <p>
      The methods and additional documentation can be found in
      <code>server.h</code>
    </p>

    <h3><code>ebb_connection</code></h3>
    <p>
      This structure contains information and callbacks for a single client
      connection. Because HTTP supports persistent connections there might
      be more than one request per connection.
    </p>

    <p>
      Once an <code>ebb_connection</code> is returned to
      <code>ebb_server</code> it begins reading requests from the socket.
      This data that comes from the socket must be stored somewhere. Because
      Ebb is agnostic about allocation decisions, it passes this off to the
      user in the form of a callback: <code>connection-&gt;new_buf</code>.
      This callback returns a newly allocated and initialized
      <code>ebb_buf</code> structure. However large this returned buffer is,
      is how much Ebb will attempt to read from the socket.  What is read
      (perhaps less than you've given Ebb space for) is stored in the
      <code>ebb_buf</code>.
    </p>

    <p>
      <code>ebb_connection</code> contains in it an
      <code>ebb_request_parser</code>. You probably don't have to interact
      with it directly.
    </p>

    <p>
      Ebb parses the data from the socket immediately. It does not buffer
      any request data.
    </p>

    <p>
      You may access the file descriptor for the client socket inside the
      <code>ebb_connection</code> structure. Writing the response, in valid
      HTTP is the user's responsibility. Remember, requests must be returned
      to client in the same order that they were received.
    </p>

    <p>
      To write to the socket first enable the <code>on_writable</code>
      callback by using <code>ebb_connection_enable_on_writable</code>. Once
      this is done the <code>on_writable</code> callback will be called each
      time the socket is available for writing. You will put your socket
      writing code inside that callback.
    </p>

    <p>
      The <code>new_request</code> callback is called at the beginning of a
      request. It must return a newly allocated and initialized
      <code>ebb_request</code> structure.
    </p>

    <p>
      Note that libebb is totally evented.  Because of this all
      callbacks ought to be non-blocking. If not you will damage
      performance.  Ebb is not at all thread safe. You may use threads for
      long running requests actions (writing to file) but they must not
      interact with the event loop.
    </p>


    <h3><code>ebb_request</code></h3>

    <p>
      This structure provides information about a request. For example,
      <code>request-&gt;method == EBB_POST</code> would mean the method of
      the request is <code>POST</code>. There are also many callback
      pointers in the structure which can be set to handle data from a
      request as it's parsed.
    </p>

    <p>
      The <code>request_complete</code> callback is called at the end of
      each request.
    </p>

    <p>
      The <code>request_uri</code> callback and all other
      <code>ebb_element_cb</code> callbacks provide pointers to request data
      which is stored in <code>ebb_buf</code> structures.  The annoying
      thing is they do not necessarily provide a complete string.  This is
      because the <code>ebb_buf</code> might store the data in
      non-continuous chunks of memory. Thus you might receive a
      <code>request_uri</code> callback 10 times, each providing just a
      single character of the request_uri.  Of course, Ebb could buffer this
      data for you but that would be less evented. Perhaps you don't even
      need that data. This is the most general solution so as not to
      infringe on any user's ability to optimize.
      See <code>request_parser.h</code> for a full list of callbacks that
      you may provide. (If you don't set them, they are ignored.)
    </p>


    <h3><code>ebb_buf</code></h3>

    <p>
      <code>ebb_buf</code> is a structure which space for Ebb to read data
      onto. It is look like this
    </p>

    <pre>
struct ebb_buf {
  char *base;
  size_t len;
  void (*free)(ebb_buf*);
};</pre>

    <p>
      The <code>base</code> should point to the allocated buffer. The
      <code>len</code> is its size. The <code>free</code> callback is made
      when Ebb is done writing and parsing the buffer.
      You do not necessarily need to free the buffer in the
      <code>free</code> callback. Especially if you continue to use the
      pointers that came from the <code>ebb_request_parser</code> callbacks
      you do not want to free the buffer because then you will not have
      access to the data any longer. 
    </p>
    
    <p>
      It is up to you to manage buffers: attach them to requests, allocate
      them with pools, or malloc and free them immediately.     
    </p>

    <p>
      For convince only, if you do not provide the <code>new_buf</code>
      callback in the <code>ebb_connection</code> class,  then it will by
      default use a simple malloc / free method.  (See
      <code>default_new_buf()</code>.)
    </p>

    <h3><code>ebb_request_parser</code></h3>

    <p>
      The request parser is used internally and will not be accessed
      directly by the user.
      It is contained inside each
      <code>ebb_connection</code>. 
    </p>

    <p>
      libebb is designed so that one may use
      <code>request_parser.{rl,h}</code> independently of the
      <code>server.{c,h}</code>. If you need a general HTTP parser but do
      not like libev or my socket processing code, feel free to use the
      request parser alone.
    </p>


    <h2>Example</h2>

    <p>
      A simple example is provided in <code>examples/hello_world.c</code>.
    </p>
    
  </div></body>
</html>
